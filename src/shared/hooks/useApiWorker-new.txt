// useApiWorker.ts
import { useRef, useState, useEffect } from "react";
import { WorkerDataRequestType } from "../types/types";
import { uniqueId } from "../utils/uniqueId";

// Module-level worker and queue (shared across all hook instances)
const apiWorker = new Worker(new URL("../workers/api/api.worker", import.meta.url));

// Queue stores data per hook
interface QueueEntry<T>{
  data: T; triggerUpdate: () => void; lastRequest?: number
}

const responseQueue: Record<string, QueueEntry<unknown >> = {};

// Worker onmessage: update only the relevant hook
apiWorker.onmessage = (event: MessageEvent) => {
  const { hookId, data } = event.data;
  if (!hookId || !responseQueue[hookId]) return;

  const entry = responseQueue[hookId];
  entry.data = data;

  // Trigger the component update
  entry.triggerUpdate();
};

// Hook implementation
export const useApiWorker = <T>(dataRequest: WorkerDataRequestType): T | undefined => {
  // Stable hook ID
  const hookIdRef = useRef<string>(uniqueId());
  const hookId = hookIdRef.current;

  // Trigger to notify the component
  const [, triggerUpdate] = useState(0);

  // Initialize queue entry if missing
  if (!responseQueue[hookId]) {
    responseQueue[hookId] = { data: undefined, triggerUpdate: () => triggerUpdate((n) => n + 1) };
  }

  // Guard: only post message if last request > 1000ms ago
  const now = Date.now();
  const lastRequest = responseQueue[hookId].lastRequest ?? 0;
  if (!lastRequest || now - lastRequest > 1000) {
    responseQueue[hookId].lastRequest = now;
    apiWorker.postMessage({ hookId, dataRequest });
  }

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      delete responseQueue[hookId];
    };
  }, [hookId]);

  return responseQueue[hookId]?.data as T | undefined;
};
